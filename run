#!/usr/bin/env python3
"""
Automation tool for building and running virtual machine images.
Equivalent to the Makefile tasks, with updated configuration and improved readability.
"""

import os
import sys
import argparse
import subprocess
import shutil
import tarfile
import requests

from config.config import config
from src.dependencies import install_dependencies
from src.create_new_vm import create_vm_image
from src.build_initramfs import build_initramfs
from src.build_content import build_guest_content
from src.create_vm_config import create_vm_config_file
from src.setup_guest import setup_guest


# -----------------------------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------------------------
def run_command(cmd):
    """
    Run a shell command and exit if it fails.
    """
    print(f"Running: {cmd}")
    try:
        subprocess.run(cmd, shell=True, check=True)
    except subprocess.CalledProcessError as e:
        print(f"Command failed: {cmd}")
        sys.exit(e.returncode)


# -----------------------------------------------------------------------------
# Initialization & Setup Functions
# -----------------------------------------------------------------------------
def init():
    """
    Initialize the build environment:
      - Create necessary directories.
      - Install dependencies.
      - Download and extract SNP release.
      - Build attestation server and digest calculator.
    """

    # Go thru all config.dir and create the directories if they don't exist
    for d in config.dir.__dict__.values():
        if isinstance(d, str):
            os.makedirs(d, exist_ok=True)
            print(f"Ensured directory exists: {d}")

    # Install dependencies.
    install_dependencies(force=False)

    # Download and extract SNP release tarball.
    tarball = os.path.join(config.dir.build, "snp-release.tar.gz")
    url = "https://github.com/SNPGuard/snp-guard/releases/download/v0.1.2/snp-release.tar.gz"
    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        with open(tarball, "wb") as f:
            shutil.copyfileobj(r.raw, f)
    run_command(f"tar -xf {tarball} -C {config.dir.build}")
    run_command(f"rm {tarball}")

    # Build attestation server binaries.
    run_command("cargo build --manifest-path=tools/attestation_server/Cargo.toml")
    for binary in [
        "server",
        "client",
        "get_report",
        "idblock-generator",
        "sev-feature-info",
        "verify_report",
    ]:
        src = os.path.join("tools", "attestation_server", "target", "debug", binary)
        run_command(f"cp {src} {config.dir.bin}")

    # Build digest calculator binary.
    run_command("cargo build --manifest-path=tools/digest_calc/Cargo.toml")
    run_command(f"cp ./tools/digest_calc/target/debug/digest_calc {config.dir.bin}")


def create_vm():
    """
    Create a new virtual machine image using the provided template.
    """
    guest_dir = config.dir.guest
    image_name = config.vm_image_base_name
    template_user_data = config.vm_template_user_data
    create_vm_image(
        new_vm=image_name, build_dir=guest_dir, template_user_data=template_user_data
    )


def unpack_kernel():
    """
    Unpack the kernel package from a .deb file.
    """
    kernel_dir = config.dir.kernel
    kernel_deb = config.kernel_deb
    run_command(f"rm -rf {kernel_dir}")
    run_command(f"dpkg -x {kernel_deb} {kernel_dir}")


def initramfs_build():
    """
    Build the initramfs image using the provided script and Dockerfile.
    """
    build_dir = config.dir.build
    resource_dir = config.dir.resources
    kernel_dir = config.dir.kernel
    init_script = config.initramfs_script
    initrd = config.initrd
    dockerfile = config.initramfs_dockerfile

    build_initramfs(
        kernel_dir=kernel_dir,
        init_script=init_script,
        dockerfile=dockerfile,
        context_dir=resource_dir,
        out=initrd,
        build_dir=build_dir,
    )


def setup_vm_config():
    """
    Create the virtual machine configuration file with the required parameters.
    """
    # Build a guest definition dictionary from the flattened config.
    vm_config_definition = {
        "host_cpu_family": config.host_cpu_family,
        "vcpu_count": config.vcpu_count,
        "guest_features": config.guest_features,
        "platform_info": config.platform_info,
        "guest_policy": config.guest_policy,
        "family_id": config.family_id,
        "image_id": config.image_id,
        "min_committed_tcb": config.min_committed_tcb,
    }
    create_vm_config_file(
        out_path=config.vm_config_file,
        ovmf_path=config.ovmf,
        kernel_path=config.kernel_vmlinuz,
        initrd_path=config.initrd,
        kernel_cmdline=f"{config.cmdline} {config.verity_params}",
        vm_config=vm_config_definition,
    )


def get_hashes():
    """
    Generate measurement inputs (hashes) from the VM configuration.
    """
    digest_calc_path = os.path.join(config.dir.bin, "digest_calc")
    out_file = os.path.join(config.dir.build, "measurement-inputs.json")
    run_command(
        f"{digest_calc_path} --vm-definition {config.vm_config_file} > {out_file}"
    )


# -----------------------------------------------------------------------------
# Build Tasks
# -----------------------------------------------------------------------------
def build_base_image():
    """
    Build the base VM image by:
      1. Unpacking the kernel.
      2. Building the initramfs.
      3. Creating the VM image.
      4. Running QEMU setup.
    """
    print("===> Building base image")
    unpack_kernel()
    initramfs_build()
    create_vm()
    run_setup()


def build_guest_image():
    """
    Build the guest image by:
      1. Building guest content.
      2. Setting up verity.
      3. Creating VM configuration.
      4. Generating hash measurements.
    """
    print("===> Building guest image")
    build_content()
    setup_verity()
    setup_vm_config()
    get_hashes()


def build_content():
    """
    Build the guest content using the provided Dockerfile.
    """
    out_dir = config.dir.content
    dockerfile = config.content_dockerfile
    build_guest_content(out_dir, dockerfile)


def setup_verity():
    """
    Set up verity by running the verity setup shell script.
    """
    setup_guest(
        src_image=config.vm_image_base_path,
        build_dir=config.dir.build,
        out_image=config.verity_image,
        out_hash_tree=config.verity_hash_tree,
        out_root_hash=config.verity_root_hash,
        debug=config.debug,
    )


# -----------------------------------------------------------------------------
# Run and Network Tasks
# -----------------------------------------------------------------------------
def run_setup():
    """
    Run QEMU with the base image configuration.
    """
    cmd = (
        f"sudo -E {config.qemu_launch_script} {config.qemu_default_params} {config.qemu_extra_params} "
        f"-hda {config.vm_image_base_path} -hdb {config.vm_cloud_config} "
        f"-hb-port {config.qemu_hb_port} -qemu-port {config.qemu_port} -debug {config.debug} -enable-kvm {config.enable_kvm}"
    )
    run_command(cmd)


def start_vm():
    """
    Run the VM using QEMU with the guest image configuration.
    """
    cmd = (
        f"sudo -E {config.qemu_launch_script} {config.qemu_default_params} {config.qemu_snp_params} "
        f"-hda {config.verity_image} -hdb {config.verity_hash_tree} -load-config {config.vm_config_file} "
        f"-hb-port {config.qemu_hb_port} -qemu-port {config.qemu_port} -debug {config.debug} -enable-kvm {config.enable_kvm}"
    )
    run_command(cmd)

def start_release_vm():
    """
    Start the VM in release mode, using files from the release folder.
    """
    release_dir = os.path.join(os.getcwd(), "release") 
    verity_image = os.path.join(release_dir, os.path.basename(config.verity_image))
    verity_hash_tree = os.path.join(release_dir, os.path.basename(config.verity_hash_tree))
    vm_config_file = os.path.join(release_dir, os.path.basename(config.vm_config_file))

    cmd = (
        f"sudo -E {config.qemu_launch_script} {config.qemu_default_params} {config.qemu_snp_params} "
        f"-hda {verity_image} -hdb {verity_hash_tree} -load-config {vm_config_file} "
        f"-hb-port {config.qemu_hb_port} -qemu-port {config.qemu_port} -debug {config.debug} -enable-kvm {config.enable_kvm}"
    )
    run_command(cmd)

def package_release():
    """
    Package all files needed for starting the VM (as used in start_vm) into a release folder,
    then create a tar.gz archive of that folder with progress output. This includes the verity image,
    hash tree, and VM configuration file.
    """
    # Define the release directory path relative to the current working directory.
    release_dir = os.path.join(os.getcwd(), "release")
    
    # Clean up the release folder if it exists.
    if os.path.exists(release_dir):
        shutil.rmtree(release_dir)
    os.makedirs(release_dir, exist_ok=True)
    
    # List of files to copy.
    files_to_copy = [config.verity_image, config.verity_hash_tree, config.vm_config_file]
    
    # Copy each file into the release directory.
    for file in files_to_copy:
        if os.path.exists(file):
            shutil.copy(file, release_dir)
            print(f"Copied {file} to {release_dir}")
        else:
            print(f"Warning: {file} does not exist and cannot be copied")
    
    # Define the path for the tar.gz archive.
    tar_path = os.path.join(os.getcwd(), "release.tar.gz")
    
    # Create a tar.gz archive of the release folder with progress output.
    print(f"Packaging release folder into {tar_path} ...")
    with tarfile.open(tar_path, "w:gz") as tar:
        # Walk through the release directory to add files individually.
        for root, dirs, files in os.walk(release_dir):
            for file in files:
                full_path = os.path.join(root, file)
                # Compute the archive name relative to the release folder.
                arcname = os.path.relpath(full_path, os.path.dirname(release_dir))
                print(f"Adding {arcname} ...")
                tar.add(full_path, arcname=arcname)
    
    print(f"Packaged release folder into {tar_path}")

def download_release(url):
    """
    Download a tar.gz release from the provided URL and extract it into the release folder.
    """
    release_dir = os.path.join(os.getcwd(), "release") 
    # Clean up the release folder if it exists
    if os.path.exists(release_dir):
        shutil.rmtree(release_dir)
    os.makedirs(release_dir, exist_ok=True)

    tarball_path = os.path.join(release_dir, "release_download.tar.gz")
    print(f"Downloading release from {url} ...")
    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        with open(tarball_path, "wb") as f:
            shutil.copyfileobj(r.raw, f)
    print(f"Downloaded tarball to {tarball_path}")

    print(f"Extracting {tarball_path} to {release_dir} ...")
    # Extract the tar.gz file
    with tarfile.open(tarball_path, "r:gz") as tar:
        tar.extractall(path=release_dir)
    os.remove(tarball_path)
    print("Extraction complete.")

def setup_host():
    """
    Set up the host system using the SNP release installer.
    """
    snp_release_dir = os.path.join(config.dir.build, "snp-release")
    run_command(f"cd {snp_release_dir} && sudo ./install.sh")


def ssh_vm():
    """
    SSH into the virtual machine.
    """
    run_command(
        f"ssh -p {config.network_vm_port} -o UserKnownHostsFile={config.ssh_hosts_file} {config.network_vm_user}@{config.network_vm_host}"
    )


def clean():
    """
    Clean up the build directory.
    """
    run_command(f"rm -rf {config.dir.build}")


# -----------------------------------------------------------------------------
# Main Entry Point
# -----------------------------------------------------------------------------
def main():
    """
    Parse command-line arguments and execute the corresponding task.
    """
    parser = argparse.ArgumentParser(
        description="Automation tool equivalent to the Makefile"
    )
    parser.add_argument(
        "target",
        choices=[
            "init",
            "setup_host",
            "build_base",
            "build_guest",
            "start",
            "start_release",
            "package_release",
            "download_release",
            "ssh",
            "clean",
        ],
        help="Target task to execute",
    )
    parser.add_argument(
        "--url",
        help="URL to a tar.gz release file (required for download_release target)"
    )
    args = parser.parse_args()

    if args.target == "download_release":
        if not args.url:
            parser.error("The download_release target requires the --url argument.")
        download_release(args.url)
        sys.exit(0)

    targets = {
        "init": init,
        "setup_host": setup_host,
        "build_base": build_base_image,
        "build_guest": build_guest_image,
        "start": start_vm,
        "start_release": start_release_vm,
        "package_release": package_release,
        "ssh": ssh_vm,
        "clean": clean,
    }

    task = targets.get(args.target)
    if task:
        task()
    else:
        print(f"Unknown target: {args.target}")
        sys.exit(1)


if __name__ == "__main__":
    main()
